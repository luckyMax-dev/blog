# 撮合引擎设计思路

## 总体框架

![architecture](https://github.com/notayessir/blog/blob/main/images/engine/architecture.png)

下单撮合流程：

1. 用户通过订单服务下单，进行资金操作、订单落库，构造一个操作指令发送到 mq；
2. 撮合引擎撮合，并将撮合结果发送到 mq；
   1. 订单服务消费撮合结果，变更订单并将信息通过 mq 发送到 websocket 服务；
   2. 行情服务处理成交数据，将行情信息通过 mq 发送到 websocket 服务；
3. websocket 实时推送信息；

## Q & A

1）系统如何保证高可用？

1. 结合现在流行的容器技术，保证应用服务动态扩容；
2. MQ 高可用部署；

2）如何提高撮合引擎的性能？

1. 使用合理的数据结构，如 Treemap进行**内存撮合**；合并多个订单指令；
2. 根据币对、标的在撮合引擎的前端做路由，例如 BTC/USDT 路由到撮合引擎 A，ETH/USDT 路由到撮合引擎 B；
3. 将 MQ 的消息丢到无锁队列中异步给撮合引擎消费，而不用做 MQ 的同步 ACK（撮合引擎宕机有完整数据的恢复办法）；若使用 Java 实现，可以使用 Disruptor；

3）撮合引擎宕机了之后，如果恢复？

1. 第一种情况，主撮合引擎挂了，独立备份节点可以直接顶上；
2. 第二种情况，主备都挂了，从撮合快照服务拉取最新的撮合快照，在 MQ 中找到最新快照的当前的指令 id，重放该 id 之后的消息，完成恢复；

4）引入撮合快照服务的目的是什么，解决了什么问题？

1. 为了防止撮合引擎宕机后，从头回放操作指令带来的巨大耗时，如果一个 orderbook 已经操作上亿次，回放这些操作会很慢；
2. 有了快照之后，撮合引擎只需加载最新快照，并回放部分指令即可恢复；
3. **撮合快照也是一个撮合引擎，只是会定时的将 orderbook 保存到可靠的存储介质中，例如数据库、redis；相较于内存撮合引擎，撮合速度会慢几个级别；**

5）相较于 Raft 这些协议实现的撮合引擎，有什么优势特点？

1. Raft 协议是基于日志同步实现各节点的数据一致，如果操作上千、亿次，Raft 日志量会变得难以维护，需要更专业的人解决问题；
2. 撮合速度相对慢，中间涉及快照保存，以及协议本身的信息同步机制，是形成瓶颈的原因；